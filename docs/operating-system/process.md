# 进程与线程
* 进程：是资源分配的最小单位，一个进程可以包含多个线程。
* 线程： 是程序执行的最小单元，是系统独立调度和分配CPU的基本单位。

进程是执行中的一段应用程序，即一旦程序被载入到内存准备执行，它就是一个进程；而线程就是一个单独的指令执行序列，以及与它相关的上下文，例如 PC计数器、寄存器、调用栈等。

## 线程
* 线程（Thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程的实际运作单位。
* 一条线程是进程中的单一顺序的控制流，它同时还拥有自己独立的 调用栈（call stack）、寄存器环境（register context）、线程本地存储（thread-local storage）。
* 同一进程中的多个线程之间共享内存空间。特别是，它们会共享 执行的代码，动态分配的变量和非线程局部全局变量的值。
* 当一个线程的上下文环境驻留在处理器的寄存器中时，表示它正在处理器上执行，此时程序计数器（PC）指示了该线程正在执行或者下一执行指令所在地址。
* 特定的寄存器存储了线程相关的上下文环境，例如栈指针（stack pointer）指向调用栈顶部等。（不同的指令集体系可能会有不同）。
* 寄存器需要存储的是线程的“核心”状态，其余上下文则存储在内存中。

## 地址空间
地址空间 = 可访问地址集 + 与之相关的上下文状态。
> 对于一个32位操作系统，有`2^32 bit`空间，也就是4GB。

不同的进程拥有独立的内存空间。操作系统使用 **地址转换** 将进程所使用的虚拟地址转换为实际地址，将不同的进程所使用的地址转换到不同的内存块中，互相隔离，如图所示。
![address-space](./address-space.jpg)

## 进程

进程的组成包括**地址空间**和**一个或多个线程**。

### 为什么使用进程？
* 操作系统与用户进程之间是隔离的，用于保护操作系统。
* 进程之间是相互隔离的，互相之间不受影响。
* 进程提供了内存保护，每个进程都拥有自己单独的地址空间，不同的进程无法访问对方的内存空间。

## 上下文切换
当系统中存在多个进程/线程时，如何使所有进程均得到执行时间，从而造成多个处理同时进行的错觉呢？这时便要考虑并发了。
系统在不同的进程之间来回切换处理，从而造成所有进程都在进行处理的错觉。

* 每个“虚拟CPU”需要一个结构来存储：PC计数器，栈指针，寄存器数据等。
* 如何从一个虚拟CPU切换到另一个虚拟CPU呢？
    * 在当前状态块中，保存PC，SP，和寄存器数据。
    * 从新的状态块中，加载PC，SP，和寄存器数据。
* 如何触发上下文切换呢？
    * Timer计数器，yield，I/O，以及其他。

一旦涉及并发，就有一个基本问题，资源分配/共享的问题。
* 硬件：系统可能拥有单个的CPU，内存，I/O设备等。多个线程/进程并发时，如何使用这些资源呢？
* 并发编程API：进程以为自己对共享资源有“独占”访问权限，如何保证进程顺利工作呢？

所有的这些问题，都需要操作系统来进行协调，从而使进程在并发的时候也能够顺利使用共享资源，完成自身工作。