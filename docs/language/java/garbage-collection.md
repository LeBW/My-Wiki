# 垃圾回收机制

垃圾收集（garbage collection），也简称GC，是Java里很重要的机制，主要作用对象为**堆和方法区**。

在堆里存放着几乎所有的对象实例，垃圾收集器在对堆进行回收之前，首先要判断这些对象中哪些还“活着”，哪些已经“死去”。

首先需要了解一个比较简单通用的判断方法，虽然在Java里并没有使用，叫做**引用计数法**。
### 引用计数法
引用计数法的思想很简单，给对象添加一个引用计数器，每当有一个地方引用它的时候，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0时，代表这个对象不可能再被使用，可以被回收了。

引用计数算法（Reference Counting）实现简单，判定效率也高，但是，至少在主流的JVM虚拟机中都没有选用此方法来管理内存，其中最主要的原因就是因为它很难解决对象之间**相互循环引用**的问题。例如，对象`objA`和`objB`都有字段`instance`，并且`objA.instance=objB, objB.instance=objA`，除此之外两个对象再无任何引用，此时两个对象都不可能再被访问，但是由于它们互相引用对方，导致无法被回收。

### 可达性分析
在Java以及其他主流商业语言（C#等）的实现中，都是通过可达性分析（Reachability Analysis)的方法来判断对象是否存活的。这个算法的核心是通过一系列称为`GC Root`的对象作为起始点，从这些节点向下探索，搜索所走过的路径称为引用链，当一个对象到GC Root没有任何引用链相连，或者说从GC Root到这个对象不可达时，这个对象就被判定为可回收的对象。如图所示，对象`ojb5, obj6, obj7`虽然互相有关联，但是没有GC Root与之相连，故判定为可回收的对象。
![GC-Root](./gc-root.jpg)

所以下面的关键是，在Java语言中，哪些对象可作为`GC Root`呢？包含以下几种：
* 虚拟机栈（栈帧中的局部变量表）中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI（即一般说的Native方法）引用的对象。

在以上例子中，`objA`和`objB`的`instance`属性不能作为`GC Root`，所以这两个对象虽然互相引用，却可以被回收。

### 回收方法区
Java虚拟机规范中说过，方法区是可以不用实现垃圾收集的，而且的确，在方法区进行垃圾收集的“性价比”是很低的。在堆中，尤其是新生代中，一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。

不过在HotSpot虚拟机中，永久代的确是有垃圾收集机制的，这里主要回收两部分内容：一个是废弃常量，一个是无用类。

* 废弃常量：回收废弃常量与回收Java堆中的对象类似。以常量池中的字面量为例，例如一个字符串“abc”已经进入常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，也就是说没有任何地方引用这个字面量，如果这是发生了垃圾回收，并且有必要的话，这个常量会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

* 无用类：判断一个类是否是无用的类比判断废弃常量苛刻很多。类必须同时满足三个条件才行：
    1. 该类所有实例已被回收，也就是说Java堆中不存在任何该类实例。
    2. 加载该类的`ClassLoader`已经被回收。
    3. 该类对应的`Java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾收集算法
垃圾收集算法实现涉及大量程序细节，而且各个平台的虚拟机操作内存方法各不相同，因此这里不过多讨论算法的实现，只介绍算法的思想和发展过程。

### 标记-清除算法（Mark-Sweep)

### 复制算法

### 标记-整理算法（Mark-Compact)

### 分代收集算法
当前商业虚拟机的垃圾收集都采用**分代收集**的方法。在新生代里，每次垃圾回收都有大批对象死去，只有少量存活，因此使用复制算法，只需要付出少量对象的复制成本就可以完成收集；而老年代中由于存活率高，没有额外空间对其进行分配担保，就必须使用**标记-清理**算法或者**标记-整理**算法。

## 垃圾收集器
如果说垃圾收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。不同的厂商，不同版本的虚拟机所提供的垃圾收集器都可能会有很大区别，并且一般会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里列出JDK 1.7 Update 14后的HotSpot虚拟机所包含的所有垃圾收集器，如图所示。

![垃圾收集器](./garbage-collector.jpg)