# Java 并发基础
首先，我们要明白一个问题，为什么要使用并发编程，即：为什么要使用多线程呢？

这个问题我们从计算机底层来探讨一下：
* 在单核时代，多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。当有两个线程时就不一样了，当一个线程执行 CPU 计算时，另一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100% 了。
* 在多核时代，多线程还可以用来提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会有一个核心被用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

总之，并发编程的目的就是为了能提高程序的执行效率和运行速度。但是并发编程并不总是能够提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：
* 安全性问题。线程安全性非常复杂，因为多个线程中的执行顺序是不可预测的，所以很容易造成 竞态条件（Race Condition）。这种时候，开发者需要使用 Java 中的各种同步机制来协同这种共享数据的访问。
* 活跃性问题：包括死锁，饥饿，以及活锁。
* 性能问题：在多线程程序中，如果出现频繁的上下文切换操作，将代码极大的开销：保存和恢复执行上下文，丢失局部性，并且 CPU 时间将更多花在线程调度而不是线程运行上。

## Java 线程的生命周期和状态
Java 线程在运行的生命周期中只可能处于下面 6 种状态中的一种

![thread-state-table](./thread-state-table.png)

Java 线程状态变更图如下所示：

![thread-state](./thread-state.png)

> 由于操作系统隐藏 Java 虚拟机（JVM）种的 READY 和 RUNNING 状态，因此它只能看到 RUNNABLE 状态。所以 Java 系统一般把这两个状态统称为 RUNNABLE 状态。

### sleep 和 wait
下面说说 sleep() 和 wait() 方法的区别和共同点。

**共同点**
* 两者都可以暂停线程的运行。

**不同点**
* 两者最主要的区别是：sleep 方法没有释放锁，而 wait 方法释放了锁。
* wait 方法通常被用于线程间交互/通信，sleep 通常用于暂停执行。
* wait 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 方法，或者直接调用 notifyAll() 方法。而 sleep 方法执行完毕后，线程会自动苏醒。



## 面试常问
### 为什么我们启动线程时需要调用 start()，而不是直接调用 run()？

首先，new 一个 thread 后，线程进入了新建状态。调用 start（）方法后，会使该线程进入就绪状态，这时候当线程分配到时间片后就可以运行了，这是真正的多线程工作。

如果我们直接执行 run 方法，其实只是把 run 方法当成 main 线程下的普通方法去执行，并不是在某个线程种执行它，所以并不是多线程工作。

总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。

### 死锁，活锁，饥饿 分别是什么意思
死锁：指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

产生死锁的四个必要条件：
* 互斥条件：所谓互斥就是线程在某一时刻独占资源
* 请求与保持条件：指的是线程因请求资源而暂停时，不会放弃已获得的资源
* 不剥夺条件：进程已获得资源，在未使用完之前，不能强行剥夺。
* 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

活锁：任务或者执行者没有被阻塞，由于某些特定条件没有被满足，导致一直重复尝试，失败，尝试，失败。在并发应用程序中，通过等待随机长度的时间和回退可以有效避免活锁的发生。

饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。
