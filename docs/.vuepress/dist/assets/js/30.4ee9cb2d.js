(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{299:function(e,a,v){"use strict";v.r(a);var t=v(38),_=Object(t.a)({},function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"进程，线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程，线程","aria-hidden":"true"}},[e._v("#")]),e._v(" 进程，线程")]),e._v(" "),v("h2",{attrs:{id:"线程同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程同步","aria-hidden":"true"}},[e._v("#")]),e._v(" 线程同步")]),e._v(" "),v("h3",{attrs:{id:"锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁","aria-hidden":"true"}},[e._v("#")]),e._v(" 锁")]),e._v(" "),v("p",[e._v("用于限制多线程对共享资源的访问。")]),e._v(" "),v("p",[e._v("锁的原理实现")]),e._v(" "),v("ul",[v("li",[e._v("中断关闭与开启。（只适用于单处理器情形）")]),e._v(" "),v("li",[e._v("有read-modify-write功能的指令（例如test-and-set, compare-and-swap, etc）。")])]),e._v(" "),v("h3",{attrs:{id:"信号量（semaphore）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号量（semaphore）","aria-hidden":"true"}},[e._v("#")]),e._v(" 信号量（Semaphore）")]),e._v(" "),v("p",[e._v("PV操作。")]),e._v(" "),v("p",[e._v("生产者消费者模型")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("* mutex = 0\n* fullBuffer = 0\n* emptyBuffer = numBuffers.\n* 注意P操作顺序很重要：必须先对Buffer进行P操作再对mutex进行P操作，防止死锁。\n")])])]),v("p",[e._v("信号量比锁的功能更丰富，但是：")]),e._v(" "),v("ul",[v("li",[e._v("有时使人迷惑，双重功能性（既可以作为锁，也可以作为限制条件）")]),e._v(" "),v("li",[e._v("例如，在以上生产者消费者模型中，P的顺序很重要，但是这没有很明显地表现出来。")])]),e._v(" "),v("p",[e._v("所以提出概念更清楚的方法：用Lock作为互斥的实现，用Condition Variables作为条件限制的实现。（Monitors）")]),e._v(" "),v("h3",{attrs:{id:"monitor（lock-and-condition-variables"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#monitor（lock-and-condition-variables","aria-hidden":"true"}},[e._v("#")]),e._v(" Monitor（Lock and Condition Variables)")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Mutex Lock: m")])]),e._v(" "),v("li",[v("code",[e._v("Condition Variables: c")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("wait(c, m)")]),e._v(" "),v("ol",[v("li",[e._v("释放互斥锁m")]),e._v(" "),v("li",[e._v("在"),v("code",[e._v("c")]),e._v("的队列中，将此线程从"),v("code",[e._v("running-queue")]),e._v("转移到"),v("code",[e._v("wait-queue")])]),e._v(" "),v("li",[e._v("进入"),v("code",[e._v("sleep")]),e._v("状态。（等待其他线程的"),v("code",[e._v("signal")]),e._v("或者"),v("code",[e._v("broadcast")]),e._v("）")]),e._v(" "),v("li",[e._v("被唤醒后，重新拿回互斥锁"),v("code",[e._v("m")]),e._v("，函数结束。")])])]),e._v(" "),v("li",[v("code",[e._v("signal(c)")]),e._v(" "),v("ul",[v("li",[e._v("把"),v("code",[e._v("c")]),e._v("的"),v("code",[e._v("wait-queue")]),e._v("中的一个线程变成"),v("code",[e._v("ready")]),e._v("状态。通常在释放锁之前进行。")])])]),e._v(" "),v("li",[v("code",[e._v("broadcast(c)")]),e._v(" "),v("ul",[v("li",[e._v("将"),v("code",[e._v("c")]),e._v("的"),v("code",[e._v("wait-queue")]),e._v("中所有线程唤醒，清空"),v("code",[e._v("wait-queue")])])])]),e._v(" "),v("li",[e._v("需要注意的是"),v("code",[e._v("condition variables")]),e._v("总是和"),v("code",[e._v("mutex lock")]),e._v("配合使用，"),v("code",[e._v("mutex lock")]),e._v("用来确保对condition variable的访问是同步的。")])])])])])},[],!1,null,null,null);a.default=_.exports}}]);