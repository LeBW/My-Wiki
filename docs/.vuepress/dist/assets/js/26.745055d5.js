(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{293:function(e,t,a){"use strict";a.r(t);var s=a(38),r=Object(s.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"搭建集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#搭建集群","aria-hidden":"true"}},[e._v("#")]),e._v(" 搭建集群")]),e._v(" "),a("p",[e._v("Kubernetes是如今最为火热的容器编排软件，是谷歌严格保密十几年的秘密武器Borg的开源版本。初学者部署Kubernetes集群，建议从以下两个方面入手：")]),e._v(" "),a("ol",[a("li",[e._v("Minikube。Minikube是Kubernetes官方提供的单节点小型集群，可以轻松跑在普通的笔记本电脑上。Minikube其实就是一个虚拟机，用户可以根据"),a("a",{attrs:{href:"https://kubernetes.io/docs/setup/learning-environment/minikube/",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方指南"),a("OutboundLink")],1),e._v("进行安装。但是Minikube运行在虚拟机之上，性能有限，并且只支持单节点。如果你拥有超过一台的服务器可以使用，那么建议使用第二种方法。")]),e._v(" "),a("li",[e._v("使用kubeadm部署高可用集群。kubeadm是官方提供的快速部署Kubernetes集群的工具，目前总体上已经达到GA水平，基本满足生产使用，对于学习使用那更是绰绰有余。接下来对kubeadm部署集群的步骤进行详细地指南。")])]),e._v(" "),a("h2",{attrs:{id:"系统要求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统要求","aria-hidden":"true"}},[e._v("#")]),e._v(" 系统要求")]),e._v(" "),a("p",[e._v("CPU和内存：双核，4GB以上。\n操作系统：基于x86_64的各种Linux发行版，包括CentOS，Federa，Ubuntu等，但是内核要求在3.10及以上。这里我使用的是Centos7系统。\n容器运行时：一般情况，使用Docker作为容器运行时。")]),e._v(" "),a("h2",{attrs:{id:"修改主机名和hosts文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改主机名和hosts文件","aria-hidden":"true"}},[e._v("#")]),e._v(" 修改主机名和hosts文件")]),e._v(" "),a("p",[e._v("为了使机器之间能够相互通信，首先我们需要给机器提供合适的主机名，并且在hosts文件中添加相关映射。")]),e._v(" "),a("h3",{attrs:{id:"修改主机名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改主机名","aria-hidden":"true"}},[e._v("#")]),e._v(" 修改主机名")]),e._v(" "),a("ol",[a("li",[e._v("首先修改主机名，centos中利用"),a("code",[e._v("hostname server01")]),e._v("可以修改主机名为server01；")]),e._v(" "),a("li",[e._v("然后打开"),a("code",[e._v("/etc/sysconfig/network")]),e._v("文件，写入"),a("code",[e._v("HOSTNAME=server01")]),e._v("。")]),e._v(" "),a("li",[e._v("然后重新进入服务器，查看名称是否改变。")])]),e._v(" "),a("h3",{attrs:{id:"修改hosts文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改hosts文件","aria-hidden":"true"}},[e._v("#")]),e._v(" 修改hosts文件")]),e._v(" "),a("p",[e._v("进入每一台机器的"),a("code",[e._v("/etc/hosts")]),e._v("文件，添加所有映射关系。例如，现在我有两台机器，一台叫做master，IP地址为192.168.0.1，一台叫做node-1，IP地址为192.168.0.2，那么我需要添加以下内容：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("192.168.0.1 master\n192.168.0.2 node-1\n")])])]),a("p",[e._v("为了检验映射关系是否添加成功，我们可以利用ping命令。在master中执行"),a("code",[e._v("ping node-1")]),e._v("，在node-1中执行"),a("code",[e._v("ping master")]),e._v("，如果能够ping通，说明成功。")]),e._v(" "),a("h2",{attrs:{id:"系统基本配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统基本配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 系统基本配置")]),e._v(" "),a("p",[e._v("在每一台机器上执行以下命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("# 关闭系统交换空间使用。（每次重启机器时都需要关闭，否则kubelet启动会报错）\nswapoff -a \n\n# 关闭防火墙\nsystemctl stop firewalld\nsystemctl disable firewalld\n\n# 设置SELinux\nsetenforce 0\nsed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\n")])])]),a("p",[e._v("另外，一些Centos7用户报告了由于iptables被绕过而导致路由出错的问题，因此我们需要保证"),a("code",[e._v("net.bridge.bridge-nf-call-iptables")]),e._v("设置为1。具体来说，执行以下命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("cat <<EOF >  /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\nsysctl --system\n")])])]),a("p",[e._v("为了保证"),a("code",[e._v("br_netfilter")]),e._v("模块加载，我们需要执行以下命令：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("modprobe br_netfilter\n")])])]),a("h2",{attrs:{id:"安装docker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装docker","aria-hidden":"true"}},[e._v("#")]),e._v(" 安装Docker")]),e._v(" "),a("p",[e._v("如果没有安装过Docker，首先需要安装Docker作为容器运行时。")]),e._v(" "),a("p",[e._v("首先，尝试卸载旧版本的Docker，保证安装环境")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n")])])]),a("p",[e._v("然后安装相关依赖包\n"),a("code",[e._v("yum install -y yum-utils device-mapper-persistent-data lvm2")])]),e._v(" "),a("p",[e._v("然后将docker仓库添加到yum的源中")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n")])])]),a("p",[e._v("然后安装相应版本的Docker。这里我没有说最新版本，因为kubernetes往往没有来得及支持最新版本的Docker，所以在官网会推荐相应的版本，可以从"),a("a",{attrs:{href:"https://kubernetes.io/docs/setup/production-environment/container-runtimes/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1),e._v("查看。这里我安装的是最新的Kubernetes v1.15.0，官网推荐的Docker版本是docker-ce-18.06.2.ce，于是我用以下命令安装docker-ce-18.06.2.ce")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("yum update && yum install docker-ce-18.06.2.ce\n")])])]),a("p",[e._v("安装完毕后，使用"),a("code",[e._v("systemctl start docker")]),e._v("来运行docker。然后我们可以用"),a("code",[e._v("docker version")]),e._v("命令查看是否成功安装，如果出现Client和Server两个版本信息，说明Docker已经成功安装并且运行。（如果只有Client的信息，说明docker没有成功运行，需要用"),a("code",[e._v("systemctl status docker")]),e._v("查看相关信息，寻找错误原因）。")]),e._v(" "),a("h2",{attrs:{id:"安装kubeadm，kubelet和kubectl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装kubeadm，kubelet和kubectl","aria-hidden":"true"}},[e._v("#")]),e._v(" 安装kubeadm，kubelet和kubectl")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("kubeadm")]),e._v("：快速创建集群的工具")]),e._v(" "),a("li",[a("code",[e._v("kubelet")]),e._v("：这是一个需要在所有集群中机器上安装的组件，它用于执行开启Pod和容器等操作。")]),e._v(" "),a("li",[a("code",[e._v("kubectl")]),e._v("：与集群通信的命令行工具，官方提供的CLI。")])]),e._v(" "),a("p",[e._v("首先要在yum中添加Kubernetes的仓库源。官方源的地址为https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64，在国内无法访问，所幸阿里云为我们提供了镜像源（感谢阿里爸爸），使用以下命令添加阿里镜像源")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("cat <<EOF > /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\nenabled=1\ngpgcheck=1\nrepo_gpgcheck=1\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n")])])]),a("p",[e._v("然后运行yum install命令安装kubeadm和相关工具")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\n\nsystemctl enable --now kubelet\n")])])]),a("h2",{attrs:{id:"初始化主节点（master）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化主节点（master）","aria-hidden":"true"}},[e._v("#")]),e._v(" 初始化主节点（Master）")]),e._v(" "),a("p",[e._v("成功安装kubeadm等一系列工具后，接下来就是正式部署Kubernetes集群了。首先我们需要在Master主机上执行"),a("code",[e._v("kubeadm init")]),e._v("相关命令，将Master节点配置成功，那么此时集群也就基本成功部署了。")]),e._v(" "),a("p",[e._v("具体来说，在master主机中执行以下命令")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("kubeadm init \\\n\t--image-repository=registry.aliyuncs.com/google_containers\n\t--pod-network-cidr=10.244.0.0/16\n")])])]),a("p",[e._v("其中"),a("code",[e._v("--imge-repository")]),e._v("指向阿里云的镜像仓库，显然还是因为google镜像仓库在国内无法访问；而"),a("code",[e._v("--pod-network-cidr")]),e._v("是为了接下来的Pod间网络通信使用flannel而设置的。如果你想安装其他的网络组件，可以在官网上"),a("a",{attrs:{href:"https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1),e._v("查看所有支持的网络组件，并修改以上命令。")]),e._v(" "),a("p",[e._v("以上命令执行可能需要几分钟的时间。执行完毕后，主机点就基本上初始化成功了！")]),e._v(" "),a("blockquote",[a("p",[e._v("如果初始化失败的话，根据提示寻找原因。第一次我初始化失败后，发现可能是由于在安装kubeadm之后才修改的主机名，造成kubeadm某些配置不正确。这种情况只需卸载并重新安装kubeadm，再次运行kubeadm init相关命令即可。\n"),a("code",[e._v("$ kubeadm reset")]),e._v(" "),a("code",[e._v("$ yum remove kubeadm")]),e._v(" "),a("code",[e._v("$ yum install kubeadm --disableexcludes=kubernetes")])])]),e._v(" "),a("p",[e._v("安装成功后，会显示一些重要信息。首先按照提示执行以下命令：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("mkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n")])])]),a("p",[e._v("然后给集群安装一个Pod网络组件。这里我选择flannel组件，执行以下命令安装")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("sysctl net.bridge.bridge-nf-call-iptables=1\nkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/62e44c867a2846fefb68bd5f178daf4da3095ccb/Documentation/kube-flannel.yml\n")])])]),a("p",[e._v("安装完毕后，执行"),a("code",[e._v("kubectl get nodes")]),e._v("命令，可以发现master的状态从NotReady变成了Ready。")]),e._v(" "),a("p",[e._v("默认情况下，集群不会在Master节点上部署Pod，这意味着你的集群至少需要两个节点才能正常工作。如果你想要允许集群在Master上部署Pod，可以执行以下命令，这样即使只有一台机器，你也可以正常使用集群")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("kubectl taint nodes --all node-role.kubernetes.io/master-\n")])])]),a("p",[e._v("另外，"),a("code",[e._v("kubeadm init")]),e._v("成功后会显示有关kubeadm join的命令，我们需要保存这个命令，以便后面为集群添加节点使用。")]),e._v(" "),a("h2",{attrs:{id:"加入工作节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加入工作节点","aria-hidden":"true"}},[e._v("#")]),e._v(" 加入工作节点")]),e._v(" "),a("p",[e._v("首先仍然需要为工作节点安装docker，kubeadm等相关工具，具体步骤见上。然后执行上一步骤中保存的"),a("code",[e._v("kubeadm join")]),e._v("相关命令，就成功地将该节点添加进集群中了。")]),e._v(" "),a("p",[e._v("如果初始化时的token没有保存或者已经过期，可以在Master使用以下命令重新生成"),a("code",[e._v("kubeadm join")]),e._v("相关token及命令：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("kubeadm token create --print-join-command\n")])])]),a("h2",{attrs:{id:"验证集群是否安装完成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#验证集群是否安装完成","aria-hidden":"true"}},[e._v("#")]),e._v(" 验证集群是否安装完成")]),e._v(" "),a("p",[e._v("执行以下命令，验证集群相关Pod是否都正常创建并运行：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("kubectl get pods --all-namespaces\n")])])]),a("p",[e._v("如果所有Pod都处于Running状态，说明集群正常运行。如果发现有状态错误的Pod，执行"),a("code",[e._v("kubectl describe pod <pod_name> --namespace=kube-system")]),e._v("查看错误原因，常见的错误一般是镜像没有下载完成。")]),e._v(" "),a("p",[e._v("至此，我们就通过"),a("code",[e._v("kubeadm")]),e._v("工具实现了Kubernetes集群的快速搭建。接下来可以愉快地使用了！")]),e._v(" "),a("h2",{attrs:{id:"踩过的坑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#踩过的坑","aria-hidden":"true"}},[e._v("#")]),e._v(" 踩过的坑")]),e._v(" "),a("h3",{attrs:{id:"cgroup不支持pids子系统。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cgroup不支持pids子系统。","aria-hidden":"true"}},[e._v("#")]),e._v(" Cgroup不支持pids子系统。")]),e._v(" "),a("p",[e._v("工作节点加入后，一直是NotReady状态。describe后发现报错如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Warning  FailedNodeAllocatableEnforcement  <invalid> (x1411 over 23h)     \nkubelet, lbw-node-3   \nFailed to update Node Allocatable Limits ["kubepods"]: failed to set supported cgroup subsystems for cgroup [kubepods]: Failed to find subsystem mount for required subsystem: pids\n')])])]),a("p",[e._v("由错误日志可知是节点中的Cgroup不支持子系统pids所致。于是用"),a("code",[e._v("uname -r")]),e._v("查看内核版本：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[root@localhost ~]# uname -r \n3.10.0-327.el7.x86_64\n")])])]),a("p",[e._v("然后查看该内核所支持的CGROUP，发现的确不支持PIDS。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[root@localhost ~]# cat /boot/config-3.10.0-327.el7.x86_64  | grep CGROUP\nCONFIG_CGROUPS=y\n# CONFIG_CGROUP_DEBUG is not set\nCONFIG_CGROUP_FREEZER=y\nCONFIG_CGROUP_DEVICE=y\nCONFIG_CGROUP_CPUACCT=y\nCONFIG_CGROUP_HUGETLB=y\nCONFIG_CGROUP_PERF=y\nCONFIG_CGROUP_SCHED=y\nCONFIG_BLK_CGROUP=y\n# CONFIG_DEBUG_BLK_CGROUP is not set\nCONFIG_NETFILTER_XT_MATCH_CGROUP=m\nCONFIG_NET_CLS_CGROUP=y\nCONFIG_NETPRIO_CGROUP=m\n")])])]),a("p",[e._v("然后在运行"),a("code",[e._v("yum update -y")]),e._v("后，使用"),a("code",[e._v("yum list kernel")]),e._v("命令查看当前安装的内核.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[root@lbw-master ~]# yum list kernel\nInstalled Packages\nkernel.x86_64\t\t3.10.0-327.el7\t\t\t    @anaconda\nkernel.x86_64\t\t3.10.0-862.3.2.el7 \t\t    @updates\nkernel.x86_64\t\t3.10.0-957.21.3.el7 \t    @updates\nkernel.x86_64\t\t3.10.0-957.27.2.el7\t\t\t@updates\n")])])]),a("p",[e._v("查看新版内核所支持的CGOURP")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[root@lbw-master ~]# cat /boot/config-3.10.0-957.27.2.el7.x86_64 | grep CGROUP\nCONFIG_CGROUPS=y\n# CONFIG_CGROUP_DEBUG is not set\nCONFIG_CGROUP_FREEZER=y\nCONFIG_CGROUP_PIDS=y\nCONFIG_CGROUP_DEVICE=y\nCONFIG_CGROUP_CPUACCT=y\nCONFIG_CGROUP_HUGETLB=y\nCONFIG_CGROUP_PERF=y\nCONFIG_CGROUP_SCHED=y\nCONFIG_BLK_CGROUP=y\n# CONFIG_DEBUG_BLK_CGROUP is not set\nCONFIG_NETFILTER_XT_MATCH_CGROUP=m\nCONFIG_NET_CLS_CGROUP=y\nCONFIG_NETPRIO_CGROUP=y\n")])])]),a("p",[e._v("发现的确有PIDS支持。于是接下来就是想办法将内核进行升级了。\n用以下命令查看所有可用的内核")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('[root@lbw-master ~]# awk -F\\\' \'$1=="menuentry " {print i++ " : " $2}\' /etc/grub2.cfg\n0 : CentOS Linux (3.10.0-957.27.2.el7.x86_64) 7 (Core)\n1 : CentOS Linux (3.10.0-957.21.3.el7.x86_64) 7 (Core)\n2 : CentOS Linux (3.10.0-862.3.2.el7.x86_64) 7 (Core)\n3 : CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)\n4 : CentOS Linux (0-rescue-c4da2e677e384e85b9fd9f27eb3a9f8a) 7 (Core)\n')])])]),a("p",[e._v("用"),a("code",[e._v("grub2-set-default")]),e._v("命令设置默认启动内核。利用设为0表示使用上一个命令输出的第一个内核。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("grub2-set-default 0\n")])])]),a("p",[e._v("然后用"),a("code",[e._v("grub2-mkconfig")]),e._v("命令生成配置文件并应用在grub.config文件中。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("grub2-mkconfig -o /boot/grub2/grub.cfg\n")])])]),a("p",[e._v("执行完毕后，用"),a("code",[e._v("reboot")]),e._v("命令重启机器即可。")])])},[],!1,null,null,null);t.default=r.exports}}]);