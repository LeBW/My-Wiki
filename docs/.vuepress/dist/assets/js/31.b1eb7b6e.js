(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{429:function(v,_,t){v.exports=t.p+"assets/img/address-space.13470310.jpg"},516:function(v,_,t){"use strict";t.r(_);var a=t(45),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"进程与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[v._v("#")]),v._v(" 进程与线程")]),v._v(" "),a("ul",[a("li",[v._v("进程：是资源分配的最小单位，一个进程可以包含多个线程。")]),v._v(" "),a("li",[v._v("线程： 是程序执行的最小单元，是系统独立调度和分配CPU的基本单位。")])]),v._v(" "),a("p",[v._v("进程是执行中的一段应用程序，即一旦程序被载入到内存准备执行，它就是一个进程；而线程就是一个单独的指令执行序列，以及与它相关的上下文，例如 PC计数器、寄存器、调用栈等。")]),v._v(" "),a("h2",{attrs:{id:"线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[v._v("#")]),v._v(" 线程")]),v._v(" "),a("ul",[a("li",[v._v("线程（Thread）是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程的实际运作单位。")]),v._v(" "),a("li",[v._v("一条线程是进程中的单一顺序的控制流，它同时还拥有自己独立的 调用栈（call stack）、寄存器环境（register context）、线程本地存储（thread-local storage）。")]),v._v(" "),a("li",[v._v("同一进程中的多个线程之间共享内存空间。特别是，它们会共享 执行的代码，动态分配的变量和非线程局部全局变量的值。")]),v._v(" "),a("li",[v._v("当一个线程的上下文环境驻留在处理器的寄存器中时，表示它正在处理器上执行，此时程序计数器（PC）指示了该线程正在执行或者下一执行指令所在地址。")]),v._v(" "),a("li",[v._v("特定的寄存器存储了线程相关的上下文环境，例如栈指针（stack pointer）指向调用栈顶部等。（不同的指令集体系可能会有不同）。")]),v._v(" "),a("li",[v._v("寄存器需要存储的是线程的“核心”状态，其余上下文则存储在内存中。")])]),v._v(" "),a("h2",{attrs:{id:"地址空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#地址空间"}},[v._v("#")]),v._v(" 地址空间")]),v._v(" "),a("p",[v._v("地址空间 = 可访问地址集 + 与之相关的上下文状态。")]),v._v(" "),a("blockquote",[a("p",[v._v("对于一个32位操作系统，有"),a("code",[v._v("2^32 bit")]),v._v("空间，也就是4GB。")])]),v._v(" "),a("p",[v._v("不同的进程拥有独立的内存空间。操作系统使用 "),a("strong",[v._v("地址转换")]),v._v(" 将进程所使用的虚拟地址转换为实际地址，将不同的进程所使用的地址转换到不同的内存块中，互相隔离，如图所示。\n"),a("img",{attrs:{src:t(429),alt:"address-space"}})]),v._v(" "),a("h2",{attrs:{id:"进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[v._v("#")]),v._v(" 进程")]),v._v(" "),a("p",[v._v("进程的组成包括"),a("strong",[v._v("地址空间")]),v._v("和"),a("strong",[v._v("一个或多个线程")]),v._v("。")]),v._v(" "),a("h3",{attrs:{id:"为什么使用进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用进程"}},[v._v("#")]),v._v(" 为什么使用进程？")]),v._v(" "),a("ul",[a("li",[v._v("操作系统与用户进程之间是隔离的，用于保护操作系统。")]),v._v(" "),a("li",[v._v("进程之间是相互隔离的，互相之间不受影响。")]),v._v(" "),a("li",[v._v("进程提供了内存保护，每个进程都拥有自己单独的地址空间，不同的进程无法访问对方的内存空间。")])]),v._v(" "),a("h2",{attrs:{id:"上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文切换"}},[v._v("#")]),v._v(" 上下文切换")]),v._v(" "),a("p",[v._v("当系统中存在多个进程/线程时，如何使所有进程均得到执行时间，从而造成多个处理同时进行的错觉呢？这时便要考虑并发了。\n系统在不同的进程之间来回切换处理，从而造成所有进程都在进行处理的错觉。")]),v._v(" "),a("ul",[a("li",[v._v("每个“虚拟CPU”需要一个结构来存储：PC计数器，栈指针，寄存器数据等。")]),v._v(" "),a("li",[v._v("如何从一个虚拟CPU切换到另一个虚拟CPU呢？\n"),a("ul",[a("li",[v._v("在当前状态块中，保存PC，SP，和寄存器数据。")]),v._v(" "),a("li",[v._v("从新的状态块中，加载PC，SP，和寄存器数据。")])])]),v._v(" "),a("li",[v._v("如何触发上下文切换呢？\n"),a("ul",[a("li",[v._v("Timer计数器，yield，I/O，以及其他。")])])])]),v._v(" "),a("p",[v._v("一旦涉及并发，就有一个基本问题，资源分配/共享的问题。")]),v._v(" "),a("ul",[a("li",[v._v("硬件：系统可能拥有单个的CPU，内存，I/O设备等。多个线程/进程并发时，如何使用这些资源呢？")]),v._v(" "),a("li",[v._v("并发编程API：进程以为自己对共享资源有“独占”访问权限，如何保证进程顺利工作呢？")])]),v._v(" "),a("p",[v._v("所有的这些问题，都需要操作系统来进行协调，从而使进程在并发的时候也能够顺利使用共享资源，完成自身工作。")])])}),[],!1,null,null,null);_.default=s.exports}}]);